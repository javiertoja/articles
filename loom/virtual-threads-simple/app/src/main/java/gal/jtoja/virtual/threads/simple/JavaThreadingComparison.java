/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package gal.jtoja.virtual.threads.simple;

import java.time.Duration;
import java.util.Random;
import java.util.concurrent.*;
import java.util.function.Supplier;
import java.util.stream.IntStream;

import static java.util.function.Predicate.not;

public class JavaThreadingComparison {

    public static void main(String[] args) throws InterruptedException {
        System.out.println("Starting test giving 20 seconds to connect everything");
        System.gc();
        Thread.sleep(Duration.ofSeconds(20));

        final var pTest = new PlatformThreadTest();
        pTest.executeScenario();

        System.out.println("Pausing 10 seconds while preparing the next test");
        System.gc();
        Thread.sleep(Duration.ofSeconds(10));

        final var vTest = new VirtualThreadTest();
        vTest.executeScenario();
        System.gc();
        Thread.sleep(Duration.ofSeconds(10));

        System.out.println("Process completed");
    }

    /**
     * Platform threads scenario where a traditional implementation of the executor service using OS threads is provided
     */
    static class PlatformThreadTest implements TestScenario {


        @Override
        public void executeScenario() {
            try(final var pExecutor = Executors.newCachedThreadPool()){
                test(pExecutor);
            } catch (ExecutionException | InterruptedException | TimeoutException e) {
                throw new RuntimeException(e);
            }
        }
    }

    /**
     * Virtual Threads scenario where a virtual thread implementation of the executor service is provided
     */
    static class VirtualThreadTest implements TestScenario {
        @Override
        public void executeScenario() {
            try(final var vExecutor = Executors.newVirtualThreadPerTaskExecutor()){
                test(vExecutor);
            } catch (ExecutionException | InterruptedException | TimeoutException e) {
                throw new RuntimeException(e);
            }
        }
    }

    interface TestScenario {

        /**
         * test configuration and execution
         */
        void executeScenario();

        /**
         * Defines the test scenario to be executed
         * @param executorService - executor service implementation to test
         */
        default void test(ExecutorService executorService) throws ExecutionException, InterruptedException, TimeoutException {
            final var start = System.currentTimeMillis();
            System.out.printf("Starting testing executor implementation of %s%n", executorService.getClass().getSimpleName());

            final var random = new Random();
            random.setSeed(42);

            final var futures = IntStream.rangeClosed(1,1000)
                    .mapToObj(__ ->
                            CompletableFuture.supplyAsync(new RandomNameSupplier(random), executorService)
                    ).toList();

            CompletableFuture.allOf(futures.toArray(new CompletableFuture[futures.size()]))
                    .get(20, TimeUnit.SECONDS);

            final var completedFuturesOk = futures.stream()
                    .filter(not(CompletableFuture::isCompletedExceptionally))
                    .map(CompletableFuture::join)
                    .count();

            final var totalTime = System.currentTimeMillis() - start;

            System.out.printf("Completed Test took %s, completed %s tasks%n", totalTime, completedFuturesOk);
        }
    }

    /**
     * Asynchronous blocking that for demo purposes, it could be anything, a network call, or an internal waiting period
     */
    static class RandomNameSupplier implements Supplier<String>{

        private final Random random;

        RandomNameSupplier(Random random) {
            this.random = random;
        }

        @Override
        public String get() {
            final var seconds = random.nextLong(1, 9);
            final var tName = "Thread %s waited for %s seconds".formatted(Thread.currentThread(), seconds);
            try {
                Thread.sleep(Duration.ofSeconds(seconds));
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            return tName;
        }
    }
}
